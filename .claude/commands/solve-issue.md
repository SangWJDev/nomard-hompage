---
description: GitHub 이슈를 가져와서 해결하기 위한 상세한 실행 계획을 수립합니다
argument-hint: [이슈-번호]
---

GitHub 이슈 #$ARGUMENTS 를 해결하기 위한 상세한 계획을 수립합니다.

## 단계 1: 이슈 정보 가져오기

먼저 `gh issue view $ARGUMENTS` 명령을 실행하여 이슈의 전체 내용을 가져옵니다.

다음 정보를 확인하세요:
- 이슈 제목
- 이슈 본문 (상세 설명)
- 라벨 (bug, feature, enhancement 등)
- 댓글 (추가 컨텍스트가 있는지)
- 연관된 이슈나 PR

## 단계 2: 이슈 분석 및 이해

이슈 내용을 바탕으로 다음을 분석합니다:

### 1. 문제 정의
- **이슈 유형**: Bug / Feature / Enhancement / Refactor / Documentation
- **영향 범위**: 어떤 컴포넌트/파일/기능이 영향을 받는가?
- **사용자 영향**: 사용자에게 미치는 영향도
- **우선순위**: Critical / High / Medium / Low

### 2. 근본 원인 분석 (Bug인 경우)
- 버그가 발생하는 조건
- 재현 단계
- 예상 동작 vs 실제 동작
- 관련 코드 위치 추정

### 3. 요구사항 분석 (Feature/Enhancement인 경우)
- 구현해야 할 기능의 핵심 요구사항
- 사용자 스토리
- 성공 기준 정의

### 4. 코드베이스 탐색
이슈와 관련된 파일을 찾기 위해:
- Glob 도구로 관련 파일 패턴 검색
- Grep 도구로 관련 코드 검색
- Read 도구로 핵심 파일 읽기

**주의**: 직접 검색하지 말고 **Task 도구의 Explore agent**를 사용하여 관련 코드를 찾으세요.

## 단계 3: 해결 계획 수립

다음 구조로 상세한 실행 계획을 작성합니다:

---

# 이슈 #$ARGUMENTS 해결 계획

## 📋 이슈 요약

**제목**: [이슈 제목]
**유형**: [Bug/Feature/Enhancement]
**우선순위**: [Critical/High/Medium/Low]
**라벨**: [라벨 목록]

**문제 설명**:
[이슈에서 설명하는 문제나 요구사항을 간결하게 요약]

**영향 범위**:
- 영향받는 파일: [파일 목록]
- 영향받는 컴포넌트: [컴포넌트 목록]
- 관련 기능: [기능 목록]

---

## 🎯 해결 목표

**주요 목표**:
1. [목표 1]
2. [목표 2]
3. [목표 3]

**성공 기준**:
- [ ] [기준 1]
- [ ] [기준 2]
- [ ] [기준 3]

---

## 🔍 근본 원인 / 접근 방식

### Bug인 경우:
- **근본 원인**: [왜 이 버그가 발생했는가?]
- **재현 조건**: [어떤 상황에서 발생하는가?]
- **해결 방향**: [어떻게 수정할 것인가?]

### Feature/Enhancement인 경우:
- **구현 방식**: [어떤 기술/패턴을 사용할 것인가?]
- **설계 결정**: [주요 아키텍처 결정사항]
- **대안 검토**: [고려한 다른 접근 방식]

---

## 🔨 작업 분해

각 작업을 구체적이고 실행 가능한 단위로 분해합니다.

### **작업 1: [작업 이름]**
**우선순위**: 🔴 Critical / 🟡 High / 🟢 Medium / ⚪ Low
**크기**: S / M / L
**의존성**: [의존하는 작업 또는 "없음"]

- **설명**: [무엇을 해야 하는지 상세히]
- **결과물**: [어떤 파일/컴포넌트를 만들거나 수정하는지]
- **완료 기준**: [어떻게 완료를 확인하는지]
- **기술적 고려사항**: [특별히 주의할 점]

### **작업 2: [작업 이름]**
**우선순위**: 🟡 High
**크기**: M
**의존성**: 작업 1

- **설명**: ...
- **결과물**: ...
- **완료 기준**: ...

[모든 작업을 나열...]

---

## 🔗 의존성 그래프

```
작업 1 (Critical, S) - 기반 작업
  ├─> 작업 2 (Critical, M) - 작업 1에 의존
  ├─> 작업 3 (High, S) - 작업 1에 의존
  │    └─> 작업 5 (Medium, M) - 작업 3에 의존
  └─> 작업 4 (High, M) - 작업 1에 의존

작업 6 (Medium, S) - 병렬 실행 가능
```

---

## 📅 실행 순서

### **1단계: 기반 구축** (Critical 경로)
1. 작업 X [파일: src/...]
2. 작업 Y [파일: src/...]

### **2단계: 핵심 구현** (병렬 가능)
3. 작업 A [파일: src/...]
4. 작업 B [파일: src/...]

### **3단계: 마무리 및 테스트**
5. 작업 C [파일: src/...]
6. 테스트 및 검증

**예상 소요 시간**: [X-Y 시간]

---

## ⚠️ 리스크 및 고려사항

### **리스크 1: [리스크 이름]**
- **설명**: [어떤 리스크인지]
- **영향도**: High / Medium / Low
- **완화 전략**: [어떻게 대응할 것인지]

### **리스크 2: [리스크 이름]**
- **설명**: ...
- **영향도**: ...
- **완화 전략**: ...

---

## 🧪 테스트 계획

### **테스트 시나리오**:
1. [시나리오 1]
   - 단계: ...
   - 예상 결과: ...

2. [시나리오 2]
   - 단계: ...
   - 예상 결과: ...

### **회귀 테스트**:
- [ ] 기존 기능이 정상 작동하는지 확인
- [ ] [특정 기능 1] 테스트
- [ ] [특정 기능 2] 테스트

### **성능 체크**:
- [ ] 페이지 로딩 시간
- [ ] 번들 사이즈 영향
- [ ] 렌더링 성능

---

## 📝 구현 후 체크리스트

- [ ] 모든 TypeScript 타입 에러 해결
- [ ] ESLint 경고 없음
- [ ] 테스트 시나리오 모두 통과
- [ ] 반응형 디자인 확인 (모바일/데스크톱)
- [ ] 접근성 확인 (키보드 네비게이션, ARIA)
- [ ] 브라우저 호환성 확인
- [ ] 코드 리뷰 준비 (자체 검토)
- [ ] 커밋 메시지 작성 (이슈 번호 포함)
- [ ] 이슈에 진행 상황 업데이트

---

## 🔄 이슈 연동

구현 완료 후:
1. 커밋 메시지에 `Fixes #$ARGUMENTS` 또는 `Closes #$ARGUMENTS` 포함
2. PR 생성 시 이슈 번호 연결
3. 이슈에 구현 완료 코멘트 작성

---

## 단계 4: 사용자 승인 대기

위 계획을 작성한 후, **사용자에게 계획을 제시하고 승인을 요청**합니다.

다음과 같이 질문하세요:

> 이슈 #$ARGUMENTS에 대한 해결 계획을 작성했습니다.
>
> 위 계획을 검토해주시고, 다음 중 선택해주세요:
>
> 1. **승인 - 바로 구현 시작**: 계획대로 구현을 시작합니다
> 2. **수정 요청**: 특정 부분을 변경하거나 추가하고 싶으신 경우
> 3. **질문**: 계획에 대해 궁금한 점이 있으신 경우
> 4. **보류**: 나중에 다시 검토하고 싶으신 경우
>
> 어떻게 진행할까요?

## 단계 5: 승인 후 실행

사용자가 승인하면:

1. **TodoWrite 도구**로 작업 목록 생성
   - 계획의 각 작업을 todo 항목으로 추가
   - 상태: pending, in_progress, completed 관리

2. **순차적 구현**
   - 1단계부터 시작
   - 각 작업 시작 시 todo를 in_progress로 변경
   - 작업 완료 시 즉시 completed로 표시

3. **진행 상황 업데이트**
   - 주요 마일스톤 달성 시 사용자에게 알림
   - 예상과 다른 상황 발생 시 즉시 보고

4. **완료 및 검증**
   - 모든 작업 완료 후 테스트
   - 사용자에게 최종 확인 요청

## 프로젝트 컨텍스트

이 프로젝트는 **Korean Nomad Homepage**입니다:

### 기술 스택
- Next.js 14+ App Router
- TypeScript
- Tailwind CSS + shadcn/ui
- React hooks (로컬 상태)
- Mock 데이터 (`src/data/mock/`)

### 아키텍처 패턴
- **Server Components**: 기본값, 인터랙션 없는 컴포넌트
- **Client Components**: 'use client' - 상태, 이벤트 핸들러 필요 시
- **File-based Routing**: App Router 사용
- **Component Structure**:
  - `src/components/sections/`: 페이지 레벨 큰 섹션
  - `src/components/shared/`: 재사용 가능한 컴포넌트
  - `src/components/ui/`: shadcn/ui 기본 컴포넌트

### 코딩 컨벤션
- TypeScript strict mode
- 모든 컴포넌트에 명확한 타입 정의
- Tailwind CSS 유틸리티 우선
- Nature 테마 일관성 (earth-toned, organic)
- 접근성 고려 (ARIA, 키보드 네비게이션)
- 성능 최적화 (Image, lazy loading, memo)

### 주요 디렉토리
```
src/
├── app/              # 페이지 라우트
├── components/       # 컴포넌트
├── data/            # 데이터 소스
├── lib/             # 유틸리티
├── types/           # 타입 정의
└── utils/           # 헬퍼 함수
```

## 중요 지침

1. **코드베이스 탐색**:
   - 직접 Glob/Grep 사용하지 말고
   - **Task 도구의 Explore agent** 사용

2. **계획 우선**:
   - 코드 작성 전에 항상 계획 수립
   - 사용자 승인 후 구현 시작

3. **진행 상황 추적**:
   - TodoWrite 도구로 모든 작업 추적
   - 각 작업 완료 시 즉시 업데이트

4. **커뮤니케이션**:
   - 계획 변경 필요 시 사용자에게 먼저 알림
   - 막히는 부분 있으면 즉시 보고
